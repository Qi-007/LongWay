# RM踩坑之旅3



## 文件名中的括号需要用反斜杠（\\）转义，或者你可以使用引号将整个文件名括起来。



## 图像的直方图

图像的直方图是一个图形表示，它显示了图像中每个灰度值（或颜色值）出现的频率。直方图通常用于分析图像的亮度分布和对比度特征。以下是关于图像直方图的几个关键点：

### 1. 定义

- **灰度直方图**：对于灰度图像，直方图的横轴表示灰度级（通常从 0 到 255），纵轴表示每个灰度级的像素数量。直方图的每个条形的高度表示该灰度值的像素在图像中出现的次数。
- **颜色直方图**：对于彩色图像，通常会分别计算红色、绿色和蓝色通道的直方图。每个通道都有自己的直方图。

### 2. 直方图的用途

- **对比度分析**：通过观察直方图，可以了解图像的对比度。如果直方图集中在某个范围，可能表示图像对比度低；如果直方图分布均匀，通常表示图像对比度较高。

- **亮度分布**：直方图可以显示图像的亮度分布情况。若直方图向左偏移，说明图像偏暗；向右偏移则说明图像偏亮。

- **阈值选择**：在图像处理（如二值化）中，直方图可以帮助选择合适的阈值。Otsu 等算法就是基于直方图来确定最佳阈值。

- **直方图均衡化**：通过调整直方图，可以改善图像的对比度，增强细节。直方图均衡化是通过重新分布灰度值来实现的，使得直方图更加均匀。

  

## 大律法和三角形法

大律法（Otsu's Method）和三角形法（Triangle Method）是两种用于图像二值化的自适应阈值选择方法，它们的主要区别如下：

### 1. 方法原理

- **大律法（Otsu's Method）**：
  - 该方法通过分析图像的直方图来寻找最优阈值。它试图通过最小化类间方差（即前景和背景的像素值分布的方差）来找到最佳阈值。
  - Otsu 方法会遍历所有可能的阈值，计算在该阈值下前景和背景的方差，然后选择使得类间方差最大的阈值。
- **三角形法（Triangle Method）**：
  - 该方法通过构建图像直方图的“三角形”形状来找到阈值。其基本思想是寻找直方图中最显著的“尖点”，即通过连接直方图的最高点和最低点形成的三角形的顶点来确定最佳阈值。
  - 三角形法主要依赖于直方图的形状来判断最优阈值，通常对于简单的前景和背景分离效果较好。

### 2. 适用情况

- **大律法**：
  - 通常适用于图像中前景和背景有明显亮度差异的情况，特别是当图像的直方图是双峰的情况下。
  - 对于较复杂的图像，Otsu 方法可能会产生较好的结果。
- **三角形法**：
  - 更加简单，适用于某些特定类型的图像，特别是在前景与背景的亮度差异不大时。
  - 三角形法可能对光照变化或噪声的鲁棒性较差。

### 3. 计算复杂度

- **大律法**：
  - 由于需要遍历所有可能的阈值并计算类间方差，计算复杂度相对较高。
- **三角形法**：
  - 计算相对简单，通常速度较快，因为它只需要分析直方图的形状。

### 总结

大律法在处理具有明显前景和背景差异的图像时通常效果较好，而三角形法则是基于直方图形状的更简单的选择，适合于一些特定的场景。选择哪种方法取决于具体的图像特征和应用需求。



## 自适应阈值处理

### **1. ADAPTIVE_THRESH_MEAN_C**:

- 计算方法：在指定的邻域内，计算所有像素的简单均值作为阈值。
- 使用的公式：T(x,y)=1k∑(x′,y′)∈RI(x′,y′)−CT(x, y) = \frac{1}{k} \sum_{(x',y') \in R} I(x', y') - CT(x,y)=k1∑(x′,y′)∈RI(x′,y′)−C
- 其中，I(x′,y′)I(x', y')I(x′,y′) 是邻域内的像素值，kkk 是邻域的总像素数，CCC 是一个常数，可以调节最终的阈值（通常为 0）。
- 这种方法简单且对光照变化有一定的鲁棒性，但在边缘和纹理变化明显的区域可能不够精准。

### **2. ADAPTIVE_THRESH_GAUSSIAN_C**:

- 计算方法：在指定的邻域内，计算加权的高斯均值作为阈值。
- 使用的公式：T(x,y)=1σ∑(x′,y′)∈RI(x′,y′)⋅G(x′,y′)−CT(x, y) = \frac{1}{\sigma} \sum_{(x',y') \in R} I(x', y') \cdot G(x', y') - CT(x,y)=σ1∑(x′,y′)∈RI(x′,y′)⋅G(x′,y′)−C
- 其中，G(x′,y′)G(x', y')G(x′,y′) 是高斯函数，用于加权邻域内的像素值，更靠近中心的像素会得到更高的权重。
- 这种方法通常在光照不均匀的情况下效果更好，因为它考虑了像素间的相对重要性，能够更好地处理边缘和细节。

### 总结：

- **ADAPTIVE_THRESH_MEAN_C** 使用简单均值，适用于一般情况。
- **ADAPTIVE_THRESH_GAUSSIAN_C** 使用高斯加权均值，更适合处理光照变化较大的图像。



## 宏

宏（Macro）是编程中的一种文本替换机制，通常用于在代码中定义常量、简化复杂的代码片段或提高代码的可读性。在 C 和 C++ 中，宏由预处理器处理，可以在编译前对源代码进行替换。

### 宏的基本用法

1. **定义常量**： 宏常用于定义常量。例如：

   ```c++
   
   #define PI 3.14159
   ```

   在代码中使用 `PI` 时，编译器会在预处理阶段将其替换为 `3.14159`。

2. **定义函数-like 宏**： 宏可以接受参数，并在调用时进行替换。例如：

   ```c++
   
   #define SQUARE(x) ((x) * (x))
   ```

   使用 `SQUARE(5)` 时，编译器将其替换为 `((5) * (5))`。

### 宏的优点

- **代码简洁**：通过使用宏，可以减少重复代码，提高可读性。
- **条件编译**：宏可以用于在编译时根据条件包含或排除代码块。

### 宏的缺点

- **调试困难**：由于宏是文本替换，调试时可能会很难追踪问题，因为错误信息通常不指向原始代码。
- **没有类型检查**：宏不进行类型检查，这可能导致意外的结果或错误。

### 注意事项

使用宏时，需要小心命名冲突和潜在的副作用。为了解决这些问题，C++ 引入了 `inline` 函数和 `const` 变量，它们在很多情况下可以替代宏，提供更好的类型安全和作用域管理。





## 断言

“断言”是一种编程中的调试工具，用于在程序运行时验证某个条件是否为真。如果该条件为假，程序会中断并抛出错误，通常会输出一条错误信息，帮助开发者找出问题。

在 C++ 中，常用的断言宏是 `assert`，它的用法如下：

```c++
#include <cassert>

void myFunction(int x) {
    assert(x > 0); // 检查 x 是否大于 0
    // 如果 x 小于或等于 0，程序会终止并打印错误信息
}
```

### 断言的作用

1. **调试**：在开发过程中，断言帮助开发者捕捉潜在的错误。
2. **文档**：断言可以作为代码中的文档，说明某个条件应该成立。
3. **防止错误传播**：在函数或模块中，通过断言确保输入或状态符合预期，可以防止更严重的错误发生。





##  findContours 函数

`findContours` 函数是 OpenCV 中用于检测图像轮廓的一个重要函数。它的主要功能是从二值图像中提取轮廓信息，并将这些轮廓存储到一个向量中。函数的基本原型如下：

```c++
void cv::findContours(
    InputArray image,
    std::vector<std::vector<Point>>& contours,
    int mode,
    int method,
    Point offset = Point()
);

```

### 参数说明：

1. **image**：输入的二值图像（通常是经过阈值处理或边缘检测后的图像）。该图像必须是单通道（灰度）的。
2. **contours**：输出参数，存储找到的轮廓。每个轮廓都是一个点的向量，代表轮廓的形状。
3. **mode**：轮廓检索模式，决定如何检索轮廓：
   - `RETR_EXTERNAL`：只检索外部轮廓。
   - `RETR_LIST`：检索所有轮廓，不建立层级关系。
   - `RETR_TREE`：检索所有轮廓，并重建轮廓之间的嵌套关系。
4. **method**：轮廓逼近方法，决定如何表示轮廓：
   - `CHAIN_APPROX_SIMPLE`：压缩水平、垂直和对角线段，只保留轮廓的端点。
   - `CHAIN_APPROX_NONE`：保留所有轮廓点。
5. **offset**：可选参数，用于将轮廓点的位置偏移。

### 使用示例：

以下是一个简单的例子，演示如何使用 `findContours` 提取图像中的轮廓：

```c++
cv::Mat binaryImage; // 假设已经得到二值图像
std::vector<std::vector<cv::Point>> contours;
cv::findContours(binaryImage, contours, cv::RETR_EXTERNAL, cv::CHAIN_APPROX_SIMPLE);

// 绘制轮廓
cv::Mat contourImage = cv::Mat::zeros(binaryImage.size(), CV_8UC3);
for (size_t i = 0; i < contours.size(); i++) {
    cv::drawContours(contourImage, contours, (int)i, cv::Scalar(255, 0, 0), 2);
}

```



## RotatedRect

RotatedRect类型 ：

这是一个包含旋转矩形信息的数据结构， 它描述了一个矩形的中心点 .宽度和高度，以及旋转角度。

多用在判断轮廓之间的平行关系

## clone()

`src.clone()` 是 OpenCV 中 `Mat` 类的一个方法，用于创建一个源图像 `src` 的深拷贝。深拷贝会分配新的内存并复制图像数据，因此修改 `clone` 后的图像不会影响原始图像。



## 逻辑判断先后顺序

```c++
if (！m_gary.channels() == 1) {}
```

我的原意是想要判断图像m_gary的通道数是否等于1，如果不等于一，执行if语句内的内容。

但是在 C++ 中，`!m_gary.channels()` 会先对 `m_gary.channels()` 的结果取反（逻辑非），然后再与 `1` 进行比较。也就是说，`!m_gary.channels()` 计算出来的结果是一个布尔值，`true` 或 `false`，这与 `1` 做比较可能并不是你期望的结果。

**问题**：`!m_gary.channels() == 1` 这行代码实际上是先取 `m_gary.channels()` 的逻辑非，然后与 1 做比较，而不是判断图像是否是灰度图。

*改正*：

```c++
if(m_gary.channels() != 1){}
```

这里，`m_gary.channels()` 返回图像的通道数，灰度图的通道数为 1。如果图像的通道数不是 1（即不是灰度图），则执行图像转换。

